# encoding: utf-8

class VideoUploader < CarrierWave::Uploader::Base

  # Include RMagick or MiniMagick support:
  # include CarrierWave::RMagick
  # include CarrierWave::MiniMagick

  # No need to choose storage since config/Carrierwave.rb specifies the storage
  # Choose what kind of storage to use for this uploader:
  # storage :file
  # storage :fog

  # :store is a CarrierWave callbacks (vs. the ActiveRecord method, "store" - see video.rb).  
  # For more info, see https://github.com/carrierwaveuploader/carrierwave/wiki/How-to:-use-callbacks
  after :store, :zencode # tells Carrierwave to call method zencode() after the video file has finished uploading

  # Specifies and overrides the directory where uploaded files will be stored.
  # This is a sensible default for uploaders that are meant to be mounted:
  def store_dir
    "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
  end

  # include modules that are necessary to use zencoder_url url helper in the uploader code
  include Rails.application.routes.url_helpers # provides access to urls generated by resources in config/routes.rb
  Rails.application.routes.default_url_options = ActionMailer::Base.default_url_options
  
  # Provide a default URL as a default if there hasn't been a file uploaded:
  # def default_url
  #   # For Rails 3.1+ asset pipeline compatibility:
  #   # ActionController::Base.helpers.asset_path("fallback/" + [version_name, "default.png"].compact.join('_'))
  #
  #   "/images/fallback/" + [version_name, "default.png"].compact.join('_')
  # end

  # Process files as they are uploaded:
  # process :scale => [200, 300]
  #
  # def scale(width, height)
  #   # do something
  # end

  # Create different versions of your uploaded files:
  # version :thumb do
  #   process :resize_to_fit => [50, 50]
  # end

  # Add a white list of extensions which are allowed to be uploaded.
  # Not case sensitive - because of "%w"
	def extension_white_list
		%w(mp4 mov)
	end

  # Override the filename of the uploaded files:
  # Avoid using model.id or version_name here, see uploader/store.rb for details.
  # def filename
  #   "something.jpg" if original_filename
  # end

  
    private
  
  def zencode(*args)
    params = {
      :input         => @model.attachment.url,
      :test          => true, # https://app.zencoder.com/docs/guides/getting-started/test-jobs-and-integration-mode
	  :notifications => [zencoder_url], # tells Zencoder where to send a POST request once the encoding job is completed
	  :pass_through  => @model.id, # passes back the id of the completed video that is being encoded
      :outputs => [
        { # MP4 
          :public      => false,
          :base_url    => base_url,
          :filename    => 'mp4_' + filename_without_ext + '.mp4',
          :label       => 'webmp4',
          :format      => 'mp4',
          :audio_codec => 'aac',
          :video_codec => 'h264'
        },
        { # WebM 
          :public      => false,
          :base_url    => base_url,
          :filename    => 'webm_' + filename_without_ext + '.webm',
          :label       => 'webwebm',
          :format      => 'webm',
          :audio_codec => 'vorbis',
          :video_codec => 'vp8'
        },
        { # OGV
          :public      => false,
          :base_url    => base_url,
          :filename    => 'ogv_' + filename_without_ext + '.ogv',
          :label       => 'webogv',
          :format      => 'ogv',
          :audio_codec => 'vorbis',
          :video_codec => 'theora'
        },
        {
         :thumbnails => {
           :public      => false,
           :base_url    => base_url,
           :filename    => filename_without_ext,
           :times       => [4],
           :aspect_mode => 'preserve',
           :width       => '100',
           :height      => '100'
         }
       }
     ]
    }
	
    z_response = Zencoder::Job.create(params) # makes a request to the Zencoder API and returns a JSON response - https://app.zencoder.com/docs/api/jobs/create	
# DEBUG: Rails.logger.debug("params: #{params.inspect}")
# DEBUG: Rails.logger.debug("z_response: #{z_response.body}")
# DEBUG: Rails.logger.debug("model.meta_info: #{@model.meta_info.inspect}")	
    @model.meta_info[:request] = z_response.body # meta_info attribute is created by the store method - see models/video.rb		

	# default values for video model attributes: name, live, active.  Note, venue_id attribute is set from hidden input field in videos/index.html.erb
	@model.name = "Video_" + DateTime.now.strftime("%Y_%m_%d")
	@model.live = false
	@model.active = true
    @model.save(:validate => false)
  end
  
  def filename_without_ext
    @filename_without_ext ||= File.basename(@model.attachment.url, File.extname(@model.attachment.url))
  end
  
  def base_url # Provides the destination folder for which to store encoded files
# DEBUG: Rails.logger.debug("@base_url: #{@base_url}") # https://s3.amazonaws.com/(bucket name)/uploads/video/attachment/78
# DEBUG: Rails.logger.debug("@model.attachment.url: #{@model.attachment.url}") # https://s3.amazonaws.com/(bucket name)/uploads/video/attachment/78/uploadify_test.mov
# DEBUG: Rails.logger.debug("file.dirname(@model.attachment.url): #{file.dirname(@model.attachment.url)}") # https://s3.amazonaws.com/(bucket name)/uploads/video/attachment/78
    @base_url ||= File.dirname(@model.attachment.url)
  end
  
#  def url_for_format(prefix, extension = nil)
#    extension ||= prefix 
#    base_url + '/' + prefix + '_' + filename_without_ext + '.' + extension
#  end

end
